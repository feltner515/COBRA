//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "CartesianMeshTrimmer.h"
#include "MooseMeshUtils.h"
#include "MathUtils.h"

// C++ includes
#include <cmath> // provides round, not std::round (see http://www.cplusplus.com/reference/cmath/round/)

registerMooseObject("ReactorApp", CartesianMeshTrimmer);

InputParameters
CartesianMeshTrimmer::validParams()
{
  InputParameters params = PolygonMeshTrimmerBase::validParams();
  params.addRangeCheckedParam<std::vector<unsigned short>>(
      "trim_peripheral_region",
      std::vector<unsigned short>(4, 0),
      "trim_peripheral_region<=1",
      "Whether the peripheral region on each of the four sides will be trimmed in an assembly "
      "mesh. See documentation for numbering convention.");
  params.addParamNamesToGroup("trim_peripheral_region", "Peripheral Trimming");
  params.addClassDescription("This CartesianMeshTrimmer object performs peripheral and/or "
                             "across-center (0, 0, 0) trimming for "
                             "assembly or core 2D meshes generated by PatternedCartesianMG.");

  return params;
}

CartesianMeshTrimmer::CartesianMeshTrimmer(const InputParameters & parameters)
  : PolygonMeshTrimmerBase(parameters)
{
  _num_sides = SQUARE_NUM_SIDES;
  _trimming_start_sector =
      isParamValid("center_trim_starting_index")
          ? MathUtils::euclideanMod(getParam<short>("center_trim_starting_index") - 2, 8)
          : 8;
  _trimming_end_sector =
      isParamValid("center_trim_ending_index")
          ? MathUtils::euclideanMod(getParam<short>("center_trim_ending_index") - 2, 8)
          : 8;
  if ((_trimming_start_sector == 8 && _trimming_end_sector != 8) ||
      (_trimming_start_sector != 8 && _trimming_end_sector == 8))
    paramError("center_trim_starting_index",
               "this parameter must be provided along with center_trim_ending_index.");
  if (_trimming_start_sector == 8 && _trimming_end_sector == 8)
    _center_trim_sector_number = 8;
  else
    _center_trim_sector_number =
        MathUtils::euclideanMod(_trimming_end_sector - _trimming_start_sector, 8);
  if (_center_trim_sector_number > 4 && _center_trim_sector_number < 8)
    paramError("center_trim_starting_index",
               "the remaining mesh after center trimming defined by this parameter and "
               "center_trim_ending_index must be equal or smaller than half of the "
               "input mesh.");
  if (_center_trim_sector_number == 8 && !_center_trimming_section_boundary.empty())
    paramError("center_trimming_section_boundary",
               "this input parameter is not used if center trimming is not performed.");
}

std::unique_ptr<MeshBase>
CartesianMeshTrimmer::generate()
{
  // Check if input mesh is trimmable
  if (hasMeshProperty<bool>("square_peripheral_trimmability", _input_name) &&
      hasMeshProperty<bool>("square_center_trimmability", _input_name))
  {
    if (!getMeshProperty<bool>("square_peripheral_trimmability", _input_name) &&
        std::accumulate(_trim_peripheral_region.begin(), _trim_peripheral_region.end(), 0) > 0)
      paramError("input", "The input mesh does not have a trimmable peripheral region.");
    if (!getMeshProperty<bool>("square_center_trimmability", _input_name) &&
        _center_trim_sector_number < 8)
      paramError("input", "The input mesh cannot be trimmed through its center.");
  }
  else
    paramError("input",
               "The input mesh's meta data is not compatible with the CartesianMeshTrimmer because "
               "the trimmability mesh meta data are absent.");

  return PolygonMeshTrimmerBase::generate();
}
