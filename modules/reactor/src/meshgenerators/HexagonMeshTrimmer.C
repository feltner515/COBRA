//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "HexagonMeshTrimmer.h"
#include "MathUtils.h"
#include "MooseMeshUtils.h"

// C++ includes
#include <cmath> // provides round, not std::round (see http://www.cplusplus.com/reference/cmath/round/)

registerMooseObject("ReactorApp", HexagonMeshTrimmer);

InputParameters
HexagonMeshTrimmer::validParams()
{
  InputParameters params = PolygonMeshTrimmerBase::validParams();
  params.addRangeCheckedParam<std::vector<unsigned short>>(
      "trim_peripheral_region",
      std::vector<unsigned short>(6, 0),
      "trim_peripheral_region<=1",
      "Whether the peripheral region on each of the six sides will be trimmed "
      "in an assembly "
      "mesh. See documentation for numbering convention.");
  params.addParamNamesToGroup("trim_peripheral_region", "Peripheral Trimming");
  params.addClassDescription("This HexagonMeshTrimmer object performs peripheral and/or "
                             "across-center (0, 0, 0) trimming for "
                             "assembly or core 2D meshes generated by PatternedHexMG.");

  return params;
}

HexagonMeshTrimmer::HexagonMeshTrimmer(const InputParameters & parameters)
  : PolygonMeshTrimmerBase(parameters)
{
  _num_sides = HEXAGON_NUM_SIDES;
  _trimming_start_sector =
      isParamValid("center_trim_starting_index")
          ? MathUtils::euclideanMod(getParam<short>("center_trim_starting_index") - 3, 12)
          : 12;
  _trimming_end_sector =
      isParamValid("center_trim_ending_index")
          ? MathUtils::euclideanMod(getParam<short>("center_trim_ending_index") - 3, 12)
          : 12;
  if ((_trimming_start_sector == 12 && _trimming_end_sector != 12) ||
      (_trimming_start_sector != 12 && _trimming_end_sector == 12))
    paramError("center_trim_starting_index",
               "this parameter must be provided along with center_trim_ending_index.");
  if (_trimming_start_sector == 12 && _trimming_end_sector == 12)
    _center_trim_sector_number = 12;
  else
    _center_trim_sector_number =
        MathUtils::euclideanMod(_trimming_end_sector - _trimming_start_sector, 12);
  if (_center_trim_sector_number > 6 && _center_trim_sector_number < 12)
    paramError("center_trim_starting_index",
               "the remaining mesh after center trimming defined by this parameter and "
               "center_trim_ending_index must be equal or smaller than half of the input mesh.");
  if (_center_trim_sector_number == 12 && !_center_trimming_section_boundary.empty())
    paramError("center_trimming_section_boundary",
               "this input parameter is not used if center trimming is not "
               "performed.");
}

std::unique_ptr<MeshBase>
HexagonMeshTrimmer::generate()
{
  // Check if input mesh is trimmable
  if (hasMeshProperty<bool>("hexagon_peripheral_trimmability", _input_name) &&
      hasMeshProperty<bool>("hexagon_center_trimmability", _input_name))
  {
    if (!getMeshProperty<bool>("hexagon_peripheral_trimmability", _input_name) &&
        std::accumulate(_trim_peripheral_region.begin(), _trim_peripheral_region.end(), 0) > 0)
      paramError("input", "The input mesh does not have a trimmable peripheral region.");
    if (!getMeshProperty<bool>("hexagon_center_trimmability", _input_name) &&
        _center_trim_sector_number < 12)
      paramError("input", "The input mesh cannot be trimmed through its center.");
  }
  else
    paramError("input",
               "The input mesh is not compatible with HexagonMeshTrimmer because "
               "the trimmability mesh meta data are absent.");

  return PolygonMeshTrimmerBase::generate();
}
