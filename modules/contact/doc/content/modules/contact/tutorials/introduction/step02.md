# Step 2 - Mortar Contact

Mortar based mechanical contact is a fairly recent addition to MOOSE. While it
offers benefits such as tighter convergence and better enforcement of contact
constraints as well as a better solution quality for contact interface
quantities like the contact pressure, it is not quite as mature as the node on
face contact used in the previous step.

Mortar based contact for 3D problems is currently in an experimental stage. Edge
to edge contact and edge dropping are not fully implemented and can lead to
artifacts at sharp transitions form in-contact to out of contact.

!listing modules/contact/tutorials/introduction/step02.i

Here we show the steps for migrating a node on face contact problem (the penalty
based contact problem from the previous step) to a mortar formulation. Most of
the extra work is performed by the Contact action.

MOOSE's mortar based contact uses Lagrange multipliers for the enforcement of
the contact constraints. These Lagrange multiplieres are additional solution
variables (added by the Contact action) that live on lower dimensional
subdomains along the contact interfaces.

The Contact action automatically adds these lower dimensional subdomains, *but*
now that they exist in the simulation we have to be careful not to add any
physics on them beyond the Lagrange multipliers. This means we have to add
*block restrictions* for all our kernels, materials, and variables to only add
them to the volume subdomains.

## Input file

### `GlobalParams`

We add `block = 0` here to make sure all block restrictable objects explicitly
listed in the input (and not generated by actions) are by default restricted to
subdomain 0 (the two cantilever volumes) and not unrestricted (meaning they
would also live on the lower dimensional meshes).

Try removing those lines to see what happens. Running mechanics on the
lower dimensional subdomains will introduce an unphysical artificial stiffness
and will change the results significantly.

Besides the added block restriction we only change the Contact block.

### `Contact`

We change the [!param](/Contact/ContactAction/formulation) to `mortar` and
remove the [!param](/Contact/ContactAction/penalty) and
[!param](/Contact/ContactAction/normalize_penalty) parameters. They have no
function in mortar contact.

## Tasks and questions

### Penetration

Let's look at the penetration variable again:

> Visualize the penetration variable. You may have to rescale the visualiztion
> to start the color scale at 0. Negative pentrations are not of interest here
> (they effectively are the gap width)

You should see a maximum interpenetration of about 5.1e-9. That's quite an
improvement compared to penalty contact!

### Contact pressure

Note that the `contact_pressure` variable is added but not used with the mortar
formulation. The physical meaning of the Lagrange multiplier *is* the normal
contact pressure.

> Visualize the contact pressure by plotting the `pillars_normal_lm` variable.

### Extracting contact pressure data

To get a better picture of the contact pressure distribution along a contact
surface it can be helpful to create a line plot of the pressure.

> Look at the
> [`NodalValueSampler`](NodalValueSampler.md)[vectorpostprocessor](VectorPostprocessors/index.md)
> and see if you can use its
> [!param](/VectorPostprocessors/NodalValueSampler/block) parameter to output the
> `pillars_normal_lm` variable on the `pillars_secondary_subdomain` subdomain.

[Click here for the answer.](contact/tutorials/introduction/answer02a.md)

Once you've answered the questions and run this example we will move on to add
thermal transport and later on thermal contact. You will need to build the
`combined-opt` executable to follow along.

- [Click here to continue the tutorial](combined/tutorials/introduction/step01.md optional=true)
